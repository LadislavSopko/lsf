using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Zerox.LSF
{
    /// <summary>
    /// Provides methods to navigate the LSF DOM and access node data efficiently.
    /// It holds references to the parsed nodes and the original input byte buffer.
    /// </summary>
    public readonly struct DOMNavigator
    {
        private static readonly UTF8Encoding Utf8NoBom = new UTF8Encoding(false);

        private readonly ReadOnlyMemory<byte> _inputBuffer;
        private readonly List<LSFNode> _nodes;

        /// <summary>
        /// Initializes a new instance of the <see cref="DOMNavigator"/> struct.
        /// </summary>
        /// <param name="inputBuffer">The original input byte buffer used for parsing.</param>
        /// <param name="nodes">The list of LSFNode structures generated by the DOMBuilder.</param>
        /// <exception cref="ArgumentNullException">Thrown if nodes is null.</exception>
        public DOMNavigator(ReadOnlyMemory<byte> inputBuffer, List<LSFNode> nodes)
        {
            _inputBuffer = inputBuffer;
            _nodes = nodes ?? throw new ArgumentNullException(nameof(nodes));
        }

        /// <summary>
        /// Gets the LSFNode at the specified index.
        /// </summary>
        /// <param name="nodeIndex">The index of the node.</param>
        /// <returns>The LSFNode.</returns>
        /// <exception cref="ArgumentOutOfRangeException">Thrown if nodeIndex is invalid.</exception>
        public LSFNode GetNode(int nodeIndex)
        {
            if (nodeIndex < 0 || nodeIndex >= _nodes.Count)
            {
                throw new ArgumentOutOfRangeException(nameof(nodeIndex), "Node index is out of range.");
            }
            return _nodes[nodeIndex];
        }

        /// <summary>
        /// Gets the raw data span associated with a node (e.g., the object name, field name, or value).
        /// </summary>
        /// <param name="nodeIndex">The index of the node.</param>
        /// <returns>A ReadOnlySpan&lt;byte&gt; representing the node's data. Returns Empty if the node has no data or index is invalid.</returns>
        public ReadOnlySpan<byte> GetNodeDataSpan(int nodeIndex)
        {
            if (nodeIndex < 0 || nodeIndex >= _nodes.Count) return ReadOnlySpan<byte>.Empty;
            var node = _nodes[nodeIndex];
            if (node.DataLength <= 0) return ReadOnlySpan<byte>.Empty;
            // Ensure slice parameters are valid
            int start = Math.Min(node.DataPosition, _inputBuffer.Length);
            int length = Math.Min(node.DataLength, _inputBuffer.Length - start);
            if (length < 0) return ReadOnlySpan<byte>.Empty;
            return _inputBuffer.Span.Slice(start, length);
        }

        /// <summary>
        /// Gets the data associated with a node as a UTF-8 decoded string.
        /// </summary>
        /// <param name="nodeIndex">The index of the node.</param>
        /// <returns>The decoded string data, or string.Empty if the node has no data or index is invalid.</returns>
        public string GetNodeDataAsString(int nodeIndex)
        {
            var dataSpan = GetNodeDataSpan(nodeIndex);
            if (dataSpan.IsEmpty) return string.Empty;
            try
            {
                // For .NET Standard 2.0 compatibility, convert span to array for GetString
                return Utf8NoBom.GetString(dataSpan.ToArray()); 
            }
            catch (ArgumentException)
            {
                 // Handle potential decoding errors if data is not valid UTF-8
                 // For now, return empty string, consider logging or throwing
                 return string.Empty; 
            }
        }

        /// <summary>
        /// Gets the indices of the children for a given parent node.
        /// </summary>
        /// <param name="parentIndex">The index of the parent node.</param>
        /// <returns>An IEnumerable&lt;int&gt; of child indices, or an empty enumerable if no children or invalid parent index.</returns>
        public IEnumerable<int> GetChildrenIndices(int parentIndex)
        {
            if (parentIndex < 0 || parentIndex >= _nodes.Count) 
            {
                 return Enumerable.Empty<int>();
            }

            var parentNode = _nodes[parentIndex];
            // Use ?? operator for conciseness
            return parentNode.ChildrenIndices ?? Enumerable.Empty<int>(); 
        }

         /// <summary>
        /// Gets the number of nodes in the DOM.
        /// </summary>
        public int NodeCount => _nodes?.Count ?? 0;

        /// <summary>
        /// Gets the list of root node indices (nodes with no parent).
        /// </summary>
        public IEnumerable<int> GetRootIndices()
        {
             if (_nodes == null) yield break; 
             
            for (int i = 0; i < _nodes.Count; i++)
            {
                if (_nodes[i].ParentIndex == -1)
                {
                    yield return i;
                }
            }
        }
    }
} 