#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

// Load prompts from JSON
const prompts = JSON.parse(fs.readFileSync(path.join(__dirname, 'prompts.json'), 'utf8'));

// Escape string for C#
function escapeForCSharp(str) {
    return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r');
}

// Escape string for Python
function escapeForPython(str) {
    return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r');
}

// Generate C# file
function generateCSharp() {
    const content = `// This file is auto-generated by prompt-gen/generate.js
// DO NOT EDIT DIRECTLY - edit prompts.json and run: node implementations/prompt-gen/generate.js

namespace Zerox.LSF
{
    internal static class LLMPrompts
    {
        public const string MinimalBase = "${escapeForCSharp(prompts.minimal.base)}";
        public const string MinimalExample = "${escapeForCSharp(prompts.minimal.example)}";
        public const string DetailedBase = "${escapeForCSharp(prompts.detailed.base)}";
        public const string DetailedExample = "${escapeForCSharp(prompts.detailed.example)}";
        
        public static string GetPrompt(bool includeExample, string style)
        {
            if (style == "detailed")
            {
                return includeExample ? DetailedBase + "\\n" + DetailedExample : DetailedBase;
            }
            return includeExample ? MinimalBase + "\\n" + MinimalExample : MinimalBase;
        }
    }
}`;

    const outputPath = path.join(__dirname, '../csharp/Zerox.LSF/Zerox.LSF/LLMPrompts.cs');
    fs.writeFileSync(outputPath, content);
    console.log('âœ“ Generated C# prompts:', outputPath);
}

// Generate TypeScript file
function generateTypeScript() {
    const content = `// This file is auto-generated by prompt-gen/generate.js
// DO NOT EDIT DIRECTLY - edit prompts.json and run: node implementations/prompt-gen/generate.js

export const LLM_PROMPTS = {
  minimal: {
    base: ${JSON.stringify(prompts.minimal.base)},
    example: ${JSON.stringify(prompts.minimal.example)}
  },
  detailed: {
    base: ${JSON.stringify(prompts.detailed.base)},
    example: ${JSON.stringify(prompts.detailed.example)}
  }
};

export function getPromptText(includeExample: boolean, style: 'minimal' | 'detailed'): string {
  const prompt = LLM_PROMPTS[style];
  return includeExample ? prompt.base + '\\n' + prompt.example : prompt.base;
}`;

    const outputPath = path.join(__dirname, '../javascript/src/llm-prompts.ts');
    fs.writeFileSync(outputPath, content);
    console.log('âœ“ Generated TypeScript prompts:', outputPath);
}

// Generate Python file
function generatePython() {
    const content = `# This file is auto-generated by prompt-gen/generate.js
# DO NOT EDIT DIRECTLY - edit prompts.json and run: node implementations/prompt-gen/generate.js

MINIMAL_BASE = """${prompts.minimal.base}"""

MINIMAL_EXAMPLE = """${prompts.minimal.example}"""

DETAILED_BASE = """${prompts.detailed.base}"""

DETAILED_EXAMPLE = """${prompts.detailed.example}"""


def get_prompt_text(include_example: bool, style: str) -> str:
    """Get the prompt text for the given style."""
    if style == "detailed":
        base = DETAILED_BASE
        example = DETAILED_EXAMPLE
    else:
        base = MINIMAL_BASE
        example = MINIMAL_EXAMPLE
    
    return base + "\\n" + example if include_example else base
`;

    const outputPath = path.join(__dirname, '../python/lsf/llm_prompts.py');
    fs.writeFileSync(outputPath, content);
    console.log('âœ“ Generated Python prompts:', outputPath);
}

// Run all generators
console.log('ðŸš€ Generating prompt files for all implementations...\n');
generateCSharp();
generateTypeScript();
generatePython();
console.log('\nâœ… All prompt files generated successfully!');
console.log('\nRemember to rebuild each implementation after generation.');