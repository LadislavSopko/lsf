# LSF v3.0: A Minimal, Streaming-Safe Serialization Format for LLMs

## Abstract
Large Language Models (LLMs) are increasingly relied upon to generate structured data for use in pipelines, agents, and interactive applications. However, standard formats such as JSON, YAML, and XML are prone to structural failure when generated by LLMs, due to their strict syntactic requirements and reliance on balanced delimiters. We introduce the LLM-Safe Format (LSF), a robust, flat serialization format designed explicitly to mitigate these limitations. Version 3.0 of the LSF specification represents a radical simplification: only three structural tokens are used to express typed fields and arrays within a flat, forward-declared structure. This document presents the motivation, design, syntax, and benefits of LSF v3.0, along with comparisons to traditional formats and discussion of its applicability in real-world AI systems.

## 1. Introduction
Modern AI agents and toolchains often rely on structured data emitted by LLMs to perform downstream tasks. Unfortunately, generating valid JSON, XML, or even YAML often proves error-prone due to:
- Missing or mismatched delimiters
- Improperly escaped content
- Unexpected nesting or type mismatches

These issues result in parsing failures, wasted compute, costly retries, and added post-processing complexity. The LSF format was designed to address these pain points by radically reducing syntactic fragility.

## 2. Motivation and Design Goals
LSF v3.0 prioritizes machine readability, streamability, and resilience to LLM hallucinations. It is not intended for manual editing or human readability.

### Design Objectives:
- **Forward-Linearity**: Streaming-compatible, order-preserving parsing.
- **Minimal Grammar**: Only three structural tokens (`$o~`, `$f~`, `$v~`) and one optional type suffix (`$t~`).
- **No Nesting**: Eliminates recursion and bracket balancing errors.
- **Array Semantics by Repetition**: Multiple values under a field imply an array.
- **Error Tolerance**: Partial output can be parsed safely.

## 3. Syntax Overview
LSF v3.0 is defined using a minimal EBNF grammar:

```
lsf_document ::= ($o~object_name? field*)*
field        ::= $f~key element*
element      ::= $v~data ($t~type)?
data         ::= <any character except $o~, $f~, $v~, $t~>*
object_name  ::= <any character except $o~, $f~, $v~>+
key          ::= <any character except $o~, $f~, $v~>+
type         ::= n | f | b | d | s
```

### Structural Tokens:
| Token | Purpose        | Example         |
|-------|----------------|------------------|
| `$o~` | Object start   | `$o~user`        |
| `$f~` | Field key      | `$f~name`        |
| `$v~` | Field value    | `$v~Alice`       |
| `$t~` | Type suffix    | `$t~n` (integer) |

### Example:
```
$o~user
$f~id$v~123$t~n
$f~roles$v~admin$v~editor
$f~active$v~true$t~b
```

## 4. Type System
Type suffixes are optional but can be used to clarify disambiguation:

| Code | Type      |
|------|-----------|
| `n`  | Integer   |
| `f`  | Float     |
| `b`  | Boolean   |
| `d`  | ISO Date  |
| `s`  | String    |

## 5. Prompting and Generation
LLMs are more likely to emit structurally valid LSF output due to:
- Absence of quotes or bracket rules
- Regularity and uniqueness of tokens
- Ability to recover from malformed tokens without failure

### Sample Prompt:
```
You MUST output structured data using LSF v3.0 format.
- Objects: $o~name (optional)
- Fields: $f~key
- Values: $v~value (repeatable = array)
- Types: optional, add $t~type

Example:
$o~product
$f~name$v~Laptop
$f~price$v~999.99$t~f
$f~available$v~true$t~b
```

## 6. Comparison to Other Formats
| Feature                | JSON   | YAML   | XML    | LSF v3.0 |
|------------------------|--------|--------|--------|----------|
| Readable by humans     | ✅     | ✅     | ⚠️     | ❌       |
| Streaming-safe         | ⚠️     | ❌     | ❌     | ✅       |
| Robust to token errors | ❌     | ❌     | ❌     | ✅       |
| Easy to parse          | ⚠️     | ❌     | ❌     | ✅       |
| Token efficient        | ❌     | ⚠️     | ❌     | ✅       |

## 7. Implementation
Parsers for LSF v3.0 are available in:
- **C#**: [GitHub link]
- **TypeScript**: [GitHub link]

The parsers are single-pass, require no lookahead, and operate with linear time complexity.

## 8. Limitations
- Not intended for human authoring or editing
- Requires custom parser (not compatible with JSON tooling)
- Cannot embed LSF tokens in values (e.g., `$f~` inside a string)

## 9. Conclusion
LSF v3.0 offers a minimal, structurally resilient serialization format tailored for LLM output. It is particularly well-suited for AI agents, streaming tasks, and low-error interfaces where JSON and YAML often fail. The format enables more reliable, cost-effective, and deterministic data generation and parsing in AI applications.

## License
LSF is released as an open specification under a permissive license. Use and adapt freely.

